<!-- Array methods- Add to end -->

let fruits = ["apple", "banana"];
fruits.push("orange");
console.log(fruits);  // apple banana orange

<!-- can add multiple at once -->

fruits.push("Mango", "grape"); // ["apple", "banana", "orange", "mango", "grape"]

<!-- Push () RETURNS the new length  -->

let newlength = fruitspush("kiwi");
console.log(newlength); //6

<!-- push() â†’ adds at end
pop()  â†’ removes from end
unshift() â†’ adds at start
shift()   â†’ removes from start -->



<!-- 2- pop()- REMOVE FROM THE END -->

let fruits= ["apple", "mango", "kiwi", "avocado"];
let removed = fruits.pop();

console.log(removed);    //  "avocado" - this the removed item
console.log(fruits);      // ["apple", "mango", "kiwi"]

<!-- Pop from the empty array -->                                               

<!-- let empty= [];
let result = empty.pop();
console.log(result)   // undefined  

 Real-Life Example 1: Browser Back Button

The browser stores your history in a stack (LIFO).

When you press BACK:

let page = historyStack.pop();


But what if there is no more history?
page will be undefined, so the browser knows:

âž¡ï¸ â€œNo more pages to go back to.â€ -->


// We pop an empty array because:

ðŸ‘‰ In real programs, we donâ€™t always know whether the array has data.
ðŸ‘‰ pop() returning undefined tells the program that the array was empty.
ðŸ‘‰ It helps avoid errors and gives useful information.


<!-- 3-unshift------- Add items at the first/ start -->

let fruits = ["kiwi", "pineapple"];
fruits.unshift("Apple");
console.log(fruits);   // ["apple", "kiwi", "pineapple"]

<!--  multiple times  -->

fruits.unshift("Mango", "papaya");
console.log(fruits);  // mango papaya apple kiwi pineapple



<!-- 4- shift() -- Remove from start/1st -->

let fruits= ["apple", "mango", "pineapple"];
let removed = fruits.shift();

console.log(removed);   // apple
console.log(fruits);   // mango, pineapple


<!-- 5- splice()------ Add/ remove at any position  -->

let fruits= ["apple", "mango", "pineapple", "pomegranate"];


<!-- // remove 1 item at index 2 -->

fruits.splice(2,1);
console.log(fruits);  // apple, mango, pomegranate

<!-- add item at index 1 -->

fruits.splice(1,0, "grape");
console.log(fruits);     // apple grape mango pomegranate

<!-- Replace item at index 2: -->
 fruits.splice(2,1, "kiwi");
 console.log(fruits);    // apple grape kiwi pomegranate

<!-- syntax- array.splice(startIndex, deleteCount, item1, item2,..............) -->



<!-- Splice- Get portion of array (doesnot modify original) -->

let country = ["Nepal", "india", "china", "spain", "hungary"];

<!get items from index 1 to 3 (3 not included) -->

let sliced = country.slice(1,3);
console.log(sliced);  // india, china
console.log(country)   // ["Nepal", "india", "china", "spain", "hungary"] // no change


<!-- get from index 2 to the end -->

let fromTwo = fruits.slice(2);
console.log(fromTwo);    // china, spain, hungary

<!-- copy entire array -->

let copy = country.slice();
console.log(copy);               // ["Nepal", "india", "china", "spain", "hungary"]




<!-- concat()- combine arrays -->

let fruits = ["apple", "banana"];
let veggies = ["carrot", "potato"]'

let food = veggies.concat(fruits); 
console.log(food);   // carrot, potato, apple, banana


<!-- original array unchanged -->
 console.log(fruits);  // apple, banana
 console.log(veggies);  // carrot, potato

 
 <!-- combine multiple  -->

 let more = ["rice", "bread"];
 let all= fruits.concat(veggies, more);
 console.log(all);   // apple, banana, carrot, potato, rice, bread;


 <!-- indexOf()-- Find position of the item -->


 let fruits = ["apple", "banana", "grapes"];

 let pos = fruits.indexOf("banana");
 console.log(pos);    // 1 (first occurrence)

 let notFound = fruits.indexOf("avocado");
 console.log(notFound);    // -1 -> not in the array

 <!-- check if the item exists -->

 if (fruitsindexOf("apple")!== -1 ){
    console.log("apple found!";)
 }


 <!-- includes()-- check if items exists(easier than indexof) -->

 let fruits = [ "banana", "guava", "orange"];

 console.log(fruits.includes("banana"));  // true
 console.log(fruits.includes("kiwi"));    // false

<!-- use in conditonals -->

if (fruits.includes("apple")){
    console.log("we have apple!");
}

<!-- reverse()-- Reverse Array (modifies original) -->

let numbers = [1,2,3,4,5];
numbers.reverse();
console.log(numbers);      // 5, 4, 3, 2 ,1


<!-- sort()-- Sort array (modifies original) -->

// sort strings

let fruits= ["apple", "papaya", "kiwi", "orange"];
fruits.sort
console.log(fruits);   // apple, kiwi, oranage, papaya


// sort numbers (TRICKY)//

    let num=[1,5,2,10,15,7];
    num.sort();
    console.log(num);   // 1,2,7,10,15,5 ---- wrong

    <!-- Correct way to sort numbers -->

    nums.sort((a,b) => a - b);
    console.log(num);   // 1,2,5,7,10,15



<!--  join()- Convert array to string  -->

let fruits= ["apple", "orange", "kiwi"];

let str1 = fruits.join();
console.log(str1);  // "apple, orange, kiwi"

let str2= fruits.join(" - ");
console.log(str2); // "apple - banana - kiwi"

let str3= fruits.join("");
console.log(str3); // "applebananakiwi"


<!-- Array Length Property -->

let country = ["Nepal", "Bhutan", "Japan"];

console.log(country.length); // 3//  .length tag is used here ----->


// change length - rarely used //

country.length = 2;
console.log(country);   //"Nepal", "Bhutan" // 2 only // last item removed ---->


fruits.length = 5;
console.log(country);    // ["Nepal", "Bhutan", empty*3]


<!-- Multi dimension array -->

<!-- Arrays of arrays: -->

let matrix = [

[ 1, 2, 3],
[ 4, 5, 5],
[ 7, 8, 9],

];

console.log(matrix[0]);  // [ 1, 2, 3]
console.log(matrix[0][0]);  // [1]
console.log(matrix[1][2]);  // [5]
console.log(matrix[2][1]);  // [8]


<!-- Real examples - student grades -->

let student = [

["John", 85, 90, 88],
["Motu", 85, 90, 88],
["Patlu", 85, 90, 88],

];

console.log(student[0][0]);   // John
console.log(student[0][1]); // 85 -> John"s first grade
console.log(student[1][3]);  // 95 -> Sarah's third grade